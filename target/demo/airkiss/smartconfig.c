/*
 * Copyright (c) 2015 Qualcomm Atheros, Inc.
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 * $ATH_LICENSE_TARGET_C$
 *
 */
 
#include "string.h"
#include "qcom/basetypes.h"
#include "qcom/qcom_common.h"
#include "qcom/qcom_internal.h"
#include "qcom/qcom_misc.h"
#include "qcom/qcom_scan.h"
#include "threadx/tx_api.h"
#include "threadx/tx_queue.h"
#include "threadx/tx_thread.h"
#include "threadx/tx_byte_pool.h"
#include "smartconfig_type.h"

#define SMART_CFG_DEBUG_EN		1

#if (1 == SMART_CFG_DEBUG_EN)
	#define printf_debug_smart_cfg  printf
#else
	#define printf_debug_smart_cfg(...)
#endif

extern void  string_init(void);
extern char *strcpy(char *, const char *);
extern char *strncpy(char *, const char *, unsigned int);
void smartconfig_task_stop(void);
    
unsigned char seq_data[256];
int old_preamble, preamble_disorder, preamble_found_cnt, preamble_seq_found;
int old_magic, magic_data, magic_disorder, magic_found_cnt, magic_seq_found;
int old_prefix, prefix_data, prefix_seq_found;
int data_seq;
unsigned char seq_crc, seq_index, data_index,  data_seq_bitmap, max_seq_index, data_seq_found;
unsigned char pswd_length, pswd_crc;
unsigned char total_length, ssid_crc;
unsigned long long seq_bitmap_patten;
unsigned int found_base_length, found_magic, found_prefix;
unsigned int base_length;
unsigned char ordered_data_section[6];
unsigned char data_section[6];
unsigned char ssid_str[33] = {0};

/*
 * Table Generated by byte-wise 8-bit CRC cacluation on the polynomial
 *  X^8+X^5+X^4+1 which following CRC-8-Dallas/Maxim
 */
 
const char CRC8Table[]={
  0, 94, 188, 226, 97, 63, 221, 131, 194, 156, 126, 32, 163, 253, 31, 65,
  157, 195, 33, 127, 252, 162, 64, 30, 95, 1, 227, 189, 62, 96, 130, 220,
  35, 125, 159, 193, 66, 28, 254, 160, 225, 191, 93, 3, 128, 222, 60, 98,
  190, 224, 2, 92, 223, 129, 99, 61, 124, 34, 192, 158, 29, 67, 161, 255,
  70, 24, 250, 164, 39, 121, 155, 197, 132, 218, 56, 102, 229, 187, 89, 7,
  219, 133, 103, 57, 186, 228, 6, 88, 25, 71, 165, 251, 120, 38, 196, 154,
  101, 59, 217, 135, 4, 90, 184, 230, 167, 249, 27, 69, 198, 152, 122, 36,
  248, 166, 68, 26, 153, 199, 37, 123, 58, 100, 134, 216, 91, 5, 231, 185,
  140, 210, 48, 110, 237, 179, 81, 15, 78, 16, 242, 172, 47, 113, 147, 205,
  17, 79, 173, 243, 112, 46, 204, 146, 211, 141, 111, 49, 178, 236, 14, 80,
  175, 241, 19, 77, 206, 144, 114, 44, 109, 51, 209, 143, 12, 82, 176, 238,
  50, 108, 142, 208, 83, 13, 239, 177, 240, 174, 76, 18, 145, 207, 45, 115,
  202, 148, 118, 40, 171, 245, 23, 73, 8, 86, 180, 234, 105, 55, 213, 139,
  87, 9, 235, 181, 54, 104, 138, 212, 149, 203, 41, 119, 244, 170, 72, 22,
  233, 183, 85, 11, 136, 214, 52, 106, 43, 117, 151, 201, 74, 20, 246, 168,
  116, 42, 200, 150, 21, 75, 169, 247, 182, 232, 10, 84, 215, 137, 107, 53
};

void parameter_init(void)
{
	int i;

	old_preamble = 0;
	preamble_disorder = 0;
	preamble_found_cnt = 0;
	preamble_seq_found = 0;
	old_magic = 0;
	magic_data = 0;
	magic_disorder = 0;
	magic_found_cnt = 0;
	magic_seq_found = 0;
	old_prefix = 0;
	prefix_data = 0;
	prefix_seq_found = 0;
	data_seq = 0;
	seq_crc = 0;
	seq_index = 0;
	data_index = 0;
	data_seq_bitmap = 0;
	max_seq_index = 0;
	data_seq_found = 0;

	seq_bitmap_patten = 0;
	found_base_length = 0;
	found_magic = 0;
	found_prefix = 0;
	
	base_length = 0;

	for(i=0; i<6; i++)
	{
		data_section[i] = 0;
		ordered_data_section[i] = 0;
	}

}

//caculate CRC, the index should be counted but it's not in the data array.
unsigned char CRC8_Table(unsigned char *p, char counter, unsigned char index)
{
    unsigned char crc8 = 0;

    crc8 = CRC8Table[crc8^index];

    for( ; counter > 0; counter--){
        crc8 = CRC8Table[crc8^*p];
        p++;
    }
    return(crc8);
}

void seek_preamble(int data)
{
	int delta = data - old_preamble;
	old_preamble = data;

	if(delta == 1){
		preamble_seq_found++;
		preamble_disorder++;
	}
	else if(delta == -3 && preamble_seq_found == 3){
		preamble_found_cnt++;
		preamble_seq_found = 0;				//restart another sequence seek
		preamble_disorder++;
		base_length = data -1;		//found base length candidate
		if(preamble_found_cnt > 5 && preamble_disorder >40){	//found at least 5 sequences and at least 40 continue valid data.
			found_base_length = TRUE;
			printf_debug_smart_cfg("found base length = %d\n", base_length);
		}
	}
	else if(delta < 4 && delta >-4){
		preamble_seq_found = 0;		//restart another sequence seek
		preamble_disorder++;			//disorder founded
	}
	else{						//should restart counting
		preamble_seq_found = 0;
		preamble_disorder = 0;
		preamble_found_cnt = 0;
	}
	return;
}

void process_magic(int data)
{
	int index = ((data & 0x1f0) >> 4) ;
	int delta = index - old_magic;
	old_magic = index;

	if(index < 4){				//only check index from 0 ~ 3
		if(delta == 1){
			magic_seq_found++;
			magic_disorder++;
		}
		else if(delta == -3 && magic_seq_found == 3){
			magic_found_cnt++;
			magic_seq_found = 0;
			magic_disorder++;
			total_length =  (magic_data & 0x7f00) >> 8;
			ssid_crc = magic_data & 0xff;

			//find at least 1 sequences and at least 10 continue valid data
			if( (magic_found_cnt >= 1) && (magic_disorder > 10) ){	
				found_magic = TRUE;
				//index: count from 0
				max_seq_index =  (total_length+3)/4 -1;
				seq_bitmap_patten = (1 << (max_seq_index + 1)) -1;
				printf_debug_smart_cfg("found magic: total_length = %x, ssid_crc = %x\n", total_length, ssid_crc);
			} 
		}
		else if(delta < 4 && delta > -4){
			magic_seq_found = 0;
			magic_disorder++;
		}
		else{
			magic_seq_found = 0;
			magic_disorder = 0;
			magic_found_cnt = 0;
		}
	}
	else{					//no magic data found
		magic_seq_found = 0;
		magic_disorder = 0;
		magic_found_cnt = 0;
	}
	magic_data = ( magic_data << 4 ) | (data & 0xf);
	return;
}

void process_prefix(int data)
{
	int index = (data & 0x1f0) >> 4;
	int delta = index - old_prefix ;
	old_prefix = index;

	prefix_data = ( prefix_data << 4 ) | (data & 0xf);
		
	if(index < 8 && index > 3){				//only check index from 4 ~ 7
		if(delta == 1){
			prefix_seq_found++;
		
			if( prefix_seq_found == 4){			//prefix date is only transmitted once
				pswd_length =  (prefix_data & 0xff00) >> 8;
				pswd_crc = prefix_data & 0xff;
				found_prefix = TRUE;
				printf_debug_smart_cfg("found prefix: pswd_len = %x, pswd_crc = %x\n", pswd_length, pswd_crc);
			}
		}
	}
	else{					//no prefix data found
		prefix_seq_found = 0;
	}

	return;
}

void process_data_seq(int data)
{
       
	 /* data sequence(bit map):
	 bit8    7      6~0
	  ---------------
	  | 0 | 1 |    crc    |  ......
	  ---------------       |=> sequence header
	  | 0 | 1 |  index  |  .......
	  ---------------
	  | 1 |     data      |.........
	  ---------------       |
	  | 1 |     data      |        |
	  ---------------       |=> data
	  | 1 |     data      |        |
	  ---------------       |
	  | 1 |     data      |.........
	  ---------------

	  If b:"0101 1x1x 1x1x" is found, a data sequence is found. */
	  
	int index = (data & 0x180) >> 7;
	unsigned char crc;
	
	data_seq = (data_seq << 2)  |  index;
	data_section[data_index] = data & 0xff;
	data_index = (data_index+1) % 6;

	if( (data_seq & 0x580)  == 0x580)			//found a data sequence:0101 1x1x 1x1x
	{	
		int j = data_index;
		seq_crc = data_section[j] & 0x7F;	//note: CRC val is 7-bit long
		j = (j +1 )%6;
		seq_index = data_section[j] & 0x7F;
		j = (j +1 )%6;
		ordered_data_section[0] = data_section[j];
		j = (j +1 )%6;
		ordered_data_section[1] = data_section[j];
		j = (j +1 )%6;
		ordered_data_section[2] = data_section[j];
		j = (j +1 )%6;
		ordered_data_section[3] = data_section[j];

		if( seq_index < max_seq_index )
		{
				crc = CRC8_Table(ordered_data_section, 4, seq_index);
                printf_debug_smart_cfg("\ndata section: %x %x %x %x %x %x, crc = %x\n", seq_crc, seq_index,
							ordered_data_section[0] ,\
							ordered_data_section[1] ,\
							ordered_data_section[2] ,\
							ordered_data_section[3] ,\
							crc);
		}
		else if(seq_index == max_seq_index)//last data section
		{
			crc = CRC8_Table(ordered_data_section, (total_length - seq_index*4), seq_index);
			

		}
		else			//ignore the noise
			return ;
		if( seq_crc == (crc & 0x7F)){		
		    data_seq_bitmap |= 1 << seq_index;

			printf_debug_smart_cfg("found data section: %x %x %x %x %x %x, found seq bitmap = %x\n",
							seq_crc, 
							seq_index,
							ordered_data_section[0] ,\
							ordered_data_section[1] ,\
							ordered_data_section[2] ,\
							ordered_data_section[3] ,\
							data_seq_bitmap);

			memcpy(&seq_data[seq_index*4], ordered_data_section, 4);
		}
	}
}

smartcfg_state_t protocol_process(int data)
{
    smartcfg_state_t ret = SMARTCGF_STATE_INPROGRESS;
    
	if(!found_base_length){			//if not found base length, no need to do more processing
		seek_preamble( data );
		return SMARTCGF_STATE_FIND_BASE;	
	}
	data -= base_length;
	if(data > MAX_DATA_VAL)	{		//ignor all > 512 data, please refer Airkiss protocol
               //only use 9 bits
		return SMARTCGF_STATE_INVALID_DATA;
	}

       if(!found_prefix) {
           process_prefix(data);
           return SMARTCGF_STATE_FIND_PREFIX;
       }
	if(!found_magic)			
		process_magic(data);
	else						//already found the total length
	{
		process_data_seq(data);
		//found magic, prefix and all data section
		if(found_prefix){
			if(data_seq_bitmap == seq_bitmap_patten)
			{
            	int n;
				printf("data_seq_bitmap = %x\n", data_seq_bitmap);
				printf("total length: %d, passwd length: %d\n",total_length, pswd_length);
				printf("password w/ or w/o AES: ");
				for(n=0; n<pswd_length; n++)
					printf("0x%02X ", seq_data[n]);
				printf("\nrandon number = 0x%02X\n", seq_data[pswd_length]);
				strncpy((char *)ssid_str, (char *)seq_data+pswd_length+1, total_length-pswd_length-1);
				printf("ssid: %s\n", ssid_str);
				printf("done\n");

				ret = SMARTCGF_STATE_DONE;
			}
		}
	}

    return ret;
}

#define SMRT_CFG_POOL_SIZE (2*1024 + 512)
#define SMRT_CFG_STACK_SIZE (2 * 1024 )

TX_THREAD smartconfig_thread;
CHAR *smartconfig_stack_pointer;

//qcom_timer_t smartconfig_task_timer;

int smartconfig_start_channel;
int smartconfig_stop_channel;
int smartconfig_dwell_time;

void smartconfig_promisc_rx_cb(A_UINT8 *pData, A_UINT16 length)
{
    if (IEEE80211_FC0_TYPE_DATA == (pData[0] & IEEE80211_FC0_TYPE_MASK)) {
#ifdef CHECK_TO_DS_PACKETS
        if ((pData[1] & 0xF) == IEEE80211_FC1_DIR_TODS) {
		    int i;
            for (i=16; i<22; i++){
#else
        if ((pData[1] & 0xF) == IEEE80211_FC1_DIR_FROMDS) {
		                int i;
            for (i=4; i<10; i++){
#endif
                if(pData[i] != 0xff) {	//check Broadcast DMAC address only
                    return ;
                }
            }
            
            if (SMARTCGF_STATE_DONE == protocol_process(length)) {
                smartconfig_task_stop();
            }
        }
    }

    return;
}

void smartconfig_task_entry(unsigned long thread_id)
{
    int i,j;
    int startPromisc = 0;
    A_UINT16 count = 0;
    unsigned int channelBitMap = 0;
    QCOM_BSS_SCAN_INFO* pOut;
    qcom_start_scan_params_t scanParams;
    A_UINT32 channelId = smartconfig_start_channel -1;

    //qcom_set_ssid(0, "");
    scanParams.forceFgScan  = 1;
    scanParams.scanType     = WMI_LONG_SCAN;
    scanParams.numChannels  = 0;
    scanParams.forceScanIntervalInMs = 1;
    scanParams.homeDwellTimeInMs = 0;       
    //qcom_set_scan(0, &scanParams);
    printf_debug_smart_cfg("start scan ...");

    for (i = 0; i < 3; i++) {
        qcom_scan_all_bss_start(0, &scanParams);
        if(qcom_get_scan(0, &pOut, &count) == A_OK){
            QCOM_BSS_SCAN_INFO* info = pOut;
            for (j = 0; j < count; j++) {
                if (info[j].channel < 14) {
                    channelBitMap |= (1U << (info[j].channel));
                }
            }
        }
    }

    printf_debug_smart_cfg(" done\n scanned channel num: %d, map: 0x%04X\n", (int)count, channelBitMap);

    if (channelBitMap == 0) {
        for (i = smartconfig_start_channel; i <= smartconfig_stop_channel; i++) {
                channelBitMap |= (1U << i);
        }
    }

    if (channelBitMap == 0) {
        return;
    }

    channelId = 1;
    
    while (1) {
        if (found_base_length) {
            break;
        }

        if (channelBitMap & (1 << channelId)) {
            printf_debug_smart_cfg("set channel %d\n", channelId);
            qcom_set_channel(0, channelId);

            if (0 == startPromisc)
            {
                startPromisc = 1;
                qcom_promiscuous_enable(1);
                qcom_set_promiscuous_rx_cb((QCOM_PROMISCUOUS_CB)smartconfig_promisc_rx_cb);
            }
            
            tx_thread_sleep(smartconfig_dwell_time);
        }

        channelId = (channelId + 1) % 14;
        tx_thread_sleep(1);
    }

    return;
}

void smartconfig_task_start(int start_channel_id, int stop_channel_id, int channel_dwell_time)
{
    printf_debug_smart_cfg("Smart config start...\n");
    smartconfig_start_channel = start_channel_id;
    smartconfig_stop_channel = stop_channel_id;
    smartconfig_dwell_time = channel_dwell_time;
    
    smartconfig_stack_pointer = qcom_mem_alloc(SMRT_CFG_STACK_SIZE);

    if (NULL != smartconfig_stack_pointer) {
        tx_thread_create(&smartconfig_thread, \
                                   "smtcfg thrd", \
                                   smartconfig_task_entry, \
                                   0, \
                                   smartconfig_stack_pointer, \
                                   SMRT_CFG_STACK_SIZE, 16, 16, 4, TX_AUTO_START);
    }
    
    return;
}

void smartconfig_task_stop(void)
{
    printf_debug_smart_cfg("Smart config done\n");
    qcom_promiscuous_enable(0);
    qcom_set_promiscuous_rx_cb(NULL);
    
    if (TX_THREAD_ID == smartconfig_thread.tx_thread_id) {
        tx_thread_terminate(&smartconfig_thread);
        tx_thread_delete(&smartconfig_thread);
    }
    
    if (NULL != smartconfig_stack_pointer) {
        qcom_mem_free(smartconfig_stack_pointer);
        smartconfig_stack_pointer = NULL;
    }

    parameter_init();
    
    return;
}

